;; p99-patcher - A patcher/launcher for the project1999.org Everquest server
;; Copyright (C) 2013 Matthew Carter
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU Affero General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU Affero General Public License for more details.
;;
;; You should have received a copy of the GNU Affero General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;;; p99-patcher.lisp

(in-package #:p99-patcher)

;;; "p99-patcher" goes here. Hacks and glory await!

(eval-when (:compile-toplevel :load-toplevel :execute)
  (setf (cl-who:html-mode) :html5))

(defparameter *junk-sample-setting* "" "Just a placeholder setting")
(defparameter *toot* nil "The webserver instance")
(defparameter *eq-path* nil "The EQ install path")
(defparameter *percent-done* 0 "The EQ % done on a scan")
(defparameter *download-percent-done* 1 "The % done on a download")
(defparameter *status* "Waiting for you to scan..." "The EQ status")

(defun md5-as-string (md5-vector)
  "Convert an md5-vector, as generated by md5sum-file or md5sum-string
into a plain string for easy comparison"
  (string-downcase
   (format nil "~{~2,'0x~}" (coerce md5-vector 'list))))

(defun md5-check-file (file expected-md5)
  "Check a file to see if it matches an expected md5"
  (let ((md5 (if (probe-file file)
                 (md5-as-string (md5sum-file file))
                 "invalid-md5"))
        (expected-md5 (string-downcase expected-md5)))
    (equal md5 expected-md5)))

(defun is-gz? (file-path)
  "Check if the file is a gz or not"
  (equal "gz" (pathname-type file-path)))

(defun is-zip? (file-path)
  "Check if the file is a zip or not"
  (equal "zip" (pathname-type file-path)))

(defun gunzip (file-path)
  "Decompress a gz file"
  (setf *status* "Decompressing and installing...")
  (gzip-stream:gunzip
   file-path
   (subseq file-path 0 (- (length file-path) 3)))
  (delete-file file-path))

(defun unzip (file-path)
  "Decompress a zip file"
  (setf *status* "Decompressing and installing...")
  (zip:unzip file-path *eq-path* :if-exists :supersede)
  (delete-file file-path))

(defun time-extension ()
  "Decode universal time into something more readable"
  (multiple-value-bind
        (sec min hour day mo year)
      (get-decoded-time)
    (format nil "~2,'0d~2,'0d~2,'0d~2,'0d~2,'0d~2,'0d"
            year mo day hour min sec)))

(defun backup-file (file-path)
  "Make a backup of a file for future use"
  (let ((current-path (merge-pathnames file-path *eq-path*))
        (backup-path (merge-pathnames
                      (format nil "~a.~a" file-path (time-extension))
                      (get-path "backups/"))))
    (when (probe-file current-path)
      (ensure-directories-exist backup-path)
      (copy-file current-path backup-path))))

(defun save-with-extension (save-as uri)
  "If the uri download has a different extension than our
locally stored file, we want to make sure to save it with
the uri file name, not our save as default"
  (if (or (equal (pathname-type save-as)
                 (pathname-type uri))
          (not (pathname-type uri)))
      save-as
      (format nil "~a.~a" save-as (pathname-type uri))))

(defun download-file (save-as uri &optional uri-size)
  "Download a file and save it to the proper location"
  (let ((input (ignore-errors (http-request
                               uri
                               :want-stream t
                               :connection-timeout 2))))
    (when input ;; Only save the new file when we have input
      (let ((save-as (save-with-extension save-as uri))
            (bytes-done 0)
            (uri-size (or uri-size 1)))
        (ensure-directories-exist save-as)
        (with-open-file (file save-as
                              :direction :output
                              :if-does-not-exist :create
                              :if-exists :supersede
                              :element-type '(unsigned-byte 8))
          (loop for byte = (read-byte input nil 'eof)
             until (eq byte 'eof)
             do (progn
                  (setf *download-percent-done* (/ (incf bytes-done) uri-size))
                  (write-byte byte file)))
          (close input))
        (cond ((is-gz? uri) (gunzip save-as))
              ((is-zip? uri) (unzip save-as)))))))

(defun get-eq-path ()
  "Attempt to find common EQ paths, if they exist then return"
  (or (probe-file "C:/Program Files/Sony/EverQuest/")
      (probe-file "C:/Program Files (x86)/Sony/EverQuest/")
      (probe-file "~/.wine/drive_c/Program Files/Sony/EverQuest/")))

(defun get-path (path)
  "Check the default path we are in for portability - if the development
file path exists, use that, otherwise use the relative path to exe run"
  (or (probe-file (merge-pathnames (format nil "src/lisp/p99-patcher/~a" path)))
      (probe-file (merge-pathnames path))))

(defun get-json-file ()
  "Pull the remote JSON file from the server that provides it"
  (download-file (merge-pathnames (get-path "www/")
                                  "p99-patcher.json")
                 "http://ahungry.com/p99-patcher.json"))

(defun read-json-file (json-file)
  "Read the json file into the associated alists"
  (format nil "~{~a~}"
          (with-open-file (s json-file)
            (loop for line = (read-line s nil 'eof)
               until (eq line 'eof)
               collect (string-trim " " line)))))

(defun parse-json-file (json-string)
  "Parse out the string as needed"
  (with-input-from-string (json json-string)
    (cl-json:decode-json json)))

(defun loadscreen-image-p ()
  "Check if we already have a loadscreen image or not"
  (probe-file (merge-pathnames "loadscreen.jpg" (get-path "www/img/"))))

(defun get-loadscreen-image ()
  "Pull a loadscreen image out of the EQ directory"
  (unless (loadscreen-image-p)
    (let ((image
           (probe-file (merge-pathnames "Resources/loadscreen.jpg" *eq-path*))))
      (when image
        (copy-file image (format nil "~a~a" (get-path "www/img/")
                                 "loadscreen.jpg")))))
  (loadscreen-image-p))

(defun page-index ()
  "Show the default index/welcome page"
  (with-html-output-to-string (s nil :prologue t :indent t)
    (htm
     (:html
      (:head
       (:script :src "/js/jquery-1.10.2.min.js" :type "text/javascript")
       (:script :src "/js/main.js" :type "text/javascript")
       (:link :href "/css/main.css" :type "text/css" :rel "stylesheet")
       )
      (:body
       (:div :id "path-info"
             (fmt "Using the following
install directory: <div id='path'>~a</div> (edit settings.lisp and restart launcher to change)" *eq-path*)
             (:br)
             "Report problems to "
             (:a :href "mailto:m@ahungry.com" "m@ahungry.com")
             "/ Patcher provided by: "
             (:a :href "http://ahungry.com" "http://ahungry.com"))
       (:div :id "main"
             (:div :id "message" "Status:")
             (:img :src "/img/loadscreen.jpg" :class "loadscreen")
             (:div :id "widgets"
                   (:div :id "loadbar" (:div :id "loadfill")
                         (:div :id "download-percent-done")
                         (:div :id "status" "")
                         (:div :id "loadpercent" "100%"))
                   (:a :href "/quick-scan/" :class "async"
                       :id "quick-scan" "Scan/Patch Game")
                   (:a :href "/play-eq/" :class "async"
                       :id "play-eq" "Play EverQuest!")))
       (:a :href "/mapper/?map-name=felwithea" :target "_blank" (:h1 "Mapper"))
       (:h3 "Include the following Optional mods and tools:")
       (:input :id "auction-logger" :type "checkbox" :name "auction-logger")
       (:label :for "auction-logger" "Ahungry Realtime Auction Logger"
               (:span :class "mod-description"
                      "An auction logger/uploader - once installed simply type '/log'
in game to activate it and contribute your logs to http://ahungry.com/eqauctions"))
       (:br)
       (:br)
       (:br)
       (:br)
       )
      ))))

(defun play-eq ()
  "Play the EverQuest game by invoking the run program call"
  (sb-ext:run-program
   (or (probe-file (merge-pathnames "eq.sh" (get-path ""))) ;; *NIX users add an eq.sh to control EQ launch
       (merge-pathnames "eqgame.exe" *eq-path*))
   (list "patchme") :wait nil))

(defun delete-bad-files ()
  "Clear out/delete files that P99 has no use for, but not
before backing them up for the user just incase."
  (let ((delete-list '("arena.eqg"
                       "arena_EnvironmentEmitters.txt"
                       "lavastorm.eqg"
                       "nektulos.eqg"
                       "Nektulos_EnvironmentEmitters.txt")))
    (mapcar
     (lambda (file)
       (let ((file-path (merge-pathnames file *eq-path*)))
         (when (probe-file file-path)
           (backup-file file)
           (delete-file file-path))))
     delete-list)))

(defun quick-scan-backups ()
  "Go over the files and back up any that have invalid checksums.
This is necessary since some files may be provided via a zip that
ends up overwriting many files at once."
  (setf *status* "Backup scan...")
  (let ((file-list (parse-json-file
                    (read-json-file (get-path "www/p99-patcher.json"))))
        (counter 0))
    (mapcar
     (lambda (file)
       (setf *percent-done* (/ (incf counter) (* 2 (length file-list))))
       (setf *status* (format nil "Scanning: ~a" (cdr (assoc :filename file))))
       (let ((file-path (merge-pathnames (cdr (assoc :filename file))
                                         *eq-path*)))
         (unless (md5-check-file file-path (cdr (assoc :checksum file)))
           (setf *status* (format nil "Backing up: ~a" (cdr (assoc :filename file))))
           (backup-file (cdr (assoc :filename file))))))
     file-list)))

(defun quick-scan-downloads ()
  "Run a fast scan on files contained in the basic json file and
download any that do not match their checksums."
  (setf *status* "Download scan...")
  (let ((file-list (parse-json-file
                    (read-json-file (get-path "www/p99-patcher.json"))))
        (counter 0))
    (mapcar
     (lambda (file)
       (setf *percent-done* (/ (+ (length file-list) (incf counter))
                               (* 2 (length file-list))))
       (setf *status* (format nil "Scanning: ~a" (cdr (assoc :filename file))))
       (let ((file-path (merge-pathnames (cdr (assoc :filename file))
                                         *eq-path*)))
         (unless (md5-check-file file-path (cdr (assoc :checksum file)))
           (setf *status* (format nil "Downloading: ~a" (cdr (assoc :download file))))
           (download-file file-path
                          (cdr (assoc :download file))
                          (parse-integer (cdr (assoc :filesize file)) :junk-allowed t)))))
     file-list)))

(defun quick-scan ()
  "Perform the backups of all files and the downloads of the new ones"
  (setf *percent-done* 0)
  (get-json-file)         ;; Pull in the remote json file
  (delete-bad-files)      ;; Clear out p99 unfriendly files
  (quick-scan-backups)    ;; Create backups of mismatched files
  (quick-scan-downloads)
  (setf *status* "Scan complete (click Play EverQuest!)")) ;; Download new files

(defun set-default-pathname ()
  "Confirm our source build directory doesn't exist (otherwise just
use current directory)"
  (when (probe-file (merge-pathnames #P"src/lisp/p99-patcher/"
                                     (user-homedir-pathname)))
    (setf *default-pathname-defaults*
          (merge-pathnames #P"src/lisp/p99-patcher/"
                           (user-homedir-pathname)))))

(defun main ()
  "Start up the local webserver, do the other necessary things
when called from webserver events (scan files/play etc.)"
  (set-default-pathname)
  (unless *toot*
    ;; Start the web server
    (setf *toot* (make-instance 'hunchentoot:easy-acceptor
                                :port 4444
                                :message-log-destination nil
                                :access-log-destination nil))
    (setf (hunchentoot:acceptor-document-root *toot*)
          (get-path "www/"))
    (hunchentoot:start *toot*))

  ;; Set the default EQ path - user can change on an input
  ;; form if necessary and we will save to a file at some point
  (setf *eq-path* (get-eq-path))

  ;; Load user settings (custom eq-path etc)
  (load (merge-pathnames "settings.lisp" (get-path ""))
        :if-does-not-exist nil)

  (if *eq-path*
      (progn
        ;; Set up the loadscreen image
        (get-loadscreen-image)

        ;; Define the handlers
        (hunchentoot:define-easy-handler (uri-home :uri "/") ()
          (setf (hunchentoot:content-type*) "text/html")
          (page-index))

        (hunchentoot:define-easy-handler (uri-js :uri "/js/main.js") ()
          (setf (hunchentoot:content-type*) "text/javascript")
          (page-js))

        (hunchentoot:define-easy-handler (uri-css :uri "/css/main.css") ()
          (setf (hunchentoot:content-type*) "text/css")
          (page-css))

        (hunchentoot:define-easy-handler (uri-play-eq :uri "/play-eq/") ()
          (setf (hunchentoot:content-type*) "text/html")
          (play-eq)
          (print "Launched game!"))

        (hunchentoot:define-easy-handler (uri-percent-done :uri "/percent-done/") ()
          (setf (hunchentoot:content-type*) "text/html")
          (format nil "~d" (round (* 100 (float *percent-done*)))))

        (hunchentoot:define-easy-handler (uri-status :uri "/status/") ()
          (setf (hunchentoot:content-type*) "text/html")
          *status*)

        (hunchentoot:define-easy-handler (uri-download-percent-done :uri "/download-percent-done/") ()
          (setf (hunchentoot:content-type*) "text/html")
          (let ((dpd (round (* 100 (float *download-percent-done*)))))
            (when (> dpd 100) (setf dpd 100))
            (format nil "~d" dpd)))

        (hunchentoot:define-easy-handler (uri-quick-scan :uri "/quick-scan/") ()
          (setf (hunchentoot:content-type*) "text/html")
          (quick-scan)
          (print "All files patched and updated!"))

        (hunchentoot:define-easy-handler (uri-get-map :uri "/get-map/") (map-name)
          (setf (hunchentoot:content-type*) "text/html")
          (map-get map-name))

        (hunchentoot:define-easy-handler (uri-map-js :uri "/js/map.js") ()
          (setf (hunchentoot:content-type*) "text/javascript")
          (map-js))

        (hunchentoot:define-easy-handler (uri-get-map-player :uri "/get-map-player/") ()
          (setf (hunchentoot:content-type*) "application/json")
          (cl-json:encode-json-to-string (map-player-loc-json-friendly)))

        (hunchentoot:define-easy-handler (uri-get-map-friends :uri "/get-map-friends/") ()
          (setf (hunchentoot:content-type*) "application/json")
          (cl-json:encode-json-to-string (map-friends-loc)))

        (hunchentoot:define-easy-handler (uri-map-sync :uri "/map-sync/") ()
          (setf (hunchentoot:content-type*) "text/html")
          (map-sync))

        (hunchentoot:define-easy-handler (uri-mapper :uri "/mapper/") (map-name)
          (setf (hunchentoot:content-type*) "text/html")
          (mapper map-name))
        )
      (progn ;; else clause
        (hunchentoot:define-easy-handler (uri-home :uri "/") ()
          (setf (hunchentoot:content-type*) "text/html")
          "No EQ Path Setup, please read the README at <a
          href='https://github.com/ahungry/p99-patcher'>https://github.com/ahungry/p99-patcher</a>
          and pay attention to ALL the instructions (also read and
          understand the comments ;; in settings.lisp.)")))

  (hunchentoot:define-easy-handler
      (uri-map-receive-loc :uri "/map-receive-loc/")
      (name x y zone)
    (setf (hunchentoot:content-type*) "text/html")
    (cl-json:encode-json-to-string (map-receive-loc name x y zone)))

  (map-populate-zone-names)

  t)
